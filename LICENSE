#pragma once

#include <atomic>
#include <memory>

// Node structure for the queue
template <typename T>
struct Node {
    std::shared_ptr<T> data;
    std::atomic<Node<T>*> next;
    
    Node(T value) : data(std::make_shared<T>(value)), next(nullptr) {}
};

// Lock-free queue implementation
template <typename T>
class LockFreeQueue {
public:
    LockFreeQueue();
    ~LockFreeQueue();

    void enqueue(T value);
    std::shared_ptr<T> dequeue();

private:
    std::atomic<Node<T>*> head;
    std::atomic<Node<T>*> tail;

    void safe_delete(Node<T>* node);
};

template <typename T>
LockFreeQueue<T>::LockFreeQueue() {
    Node<T>* dummy = new Node<T>(T());  // Dummy node
    head.store(dummy, std::memory_order_relaxed);
    tail.store(dummy, std::memory_order_relaxed);
}

template <typename T>
LockFreeQueue<T>::~LockFreeQueue() {
    while (Node<T>* node = head.load(std::memory_order_relaxed)) {
        head.store(node->next.load(std::memory_order_relaxed), std::memory_order_relaxed);
        delete node;
    }
}

template <typename T>
void LockFreeQueue<T>::enqueue(T value) {
    Node<T>* newNode = new Node<T>(value);
    Node<T>* oldTail = nullptr;

    while (true) {
        oldTail = tail.load(std::memory_order_acquire);
        Node<T>* next = oldTail->next.load(std::memory_order_acquire);
        
        if (next == nullptr) {
            if (oldTail->next.compare_exchange_strong(next, newNode, std::memory_order_release, std::memory_order_relaxed)) {
                break;
            }
        } else {
            tail.compare_exchange_strong(oldTail, next, std::memory_order_release, std::memory_order_relaxed);
        }
    }
    
    tail.compare_exchange_strong(oldTail, newNode, std::memory_order_release, std::memory_order_relaxed);
}

template <typename T>
std::shared_ptr<T> LockFreeQueue<T>::dequeue() {
    Node<T>* oldHead = nullptr;

    while (true) {
        oldHead = head.load(std::memory_order_acquire);
        Node<T>* next = oldHead->next.load(std::memory_order_acquire);

        if (next == nullptr) {
            return nullptr; // Queue is empty
        }

        if (head.compare_exchange_strong(oldHead, next, std::memory_order_release, std::memory_order_relaxed)) {
            break;
        }
    }

    std::shared_ptr<T> result = next->data;
    safe_delete(oldHead);
    return result;
}

template <typename T>
void LockFreeQueue<T>::safe_delete(Node<T>* node) {
    // Hazard pointers or safe reclamation mechanism should go here
    delete node;
}

